{"version":3,"names":[],"mappings":"","sources":["bubble.js"],"sourcesContent":["\n;(function() {\n\n  \"use strict\";\n\n  var lava0;\n  var ge1doot = {\n    screen: {\n      elem:     null,\n      callback: null,\n      ctx:      null,\n      width:    0,\n      height:   0,\n      left:     0,\n      top:      0,\n      init: function (id, callback, initRes) {\n        this.elem = document.getElementById(id);\n        this.callback = callback || null;\n        if (this.elem.tagName == \"CANVAS\") this.ctx = this.elem.getContext(\"2d\");\n        window.addEventListener('resize', function () {\n          this.resize();\n        }.bind(this), false);\n        this.elem.onselectstart = function () { return false; }\n        this.elem.ondrag        = function () { return false; }\n        initRes && this.resize();\n        return this;\n      },\n      resize: function () {\n        var o = this.elem;\n        this.width  = o.offsetWidth;\n        this.height = o.offsetHeight;\n        for (this.left = 0, this.top = 0; o != null; o = o.offsetParent) {\n          this.left += o.offsetLeft;\n          this.top  += o.offsetTop;\n        }\n        if (this.ctx) {\n          this.elem.width  = this.width;\n          this.elem.height = this.height;\n        }\n        this.callback && this.callback();\n      }\n    }\n  }\n\n  // Point constructor\n  var Point = function(x, y) {\n    this.x = x;\n    this.y = y;\n    this.magnitude = x * x + y * y;\n    this.computed = 0;\n    this.force = 0;\n  };\n  Point.prototype.add = function(p) {\n    return new Point(this.x + p.x, this.y + p.y);\n  };\n\n  // Ball constructor\n  var Ball = function(parent) {\n    var min = .1;\n    var max = 1.5;\n    this.vel = new Point(\n      (Math.random() > 0.5 ? 1 : -1) * (0.2 + Math.random() * 0.25), (Math.random() > 0.5 ? 1 : -1) * (0.2 + Math.random())\n    );\n    this.pos = new Point(\n      parent.width * 0.2 + Math.random() * parent.width * 0.6,\n      parent.height * 0.2 + Math.random() * parent.height * 0.6\n    );\n    this.size = (parent.wh / 15) + ( Math.random() * (max - min) + min ) * (parent.wh / 15);\n    this.width = parent.width;\n    this.height = parent.height;\n  };\n\n  // move balls\n  Ball.prototype.move = function() {\n\n    // bounce borders\n    if (this.pos.x >= this.width - this.size) {\n      if (this.vel.x > 0) this.vel.x = -this.vel.x;\n      this.pos.x = this.width - this.size;\n    } else if (this.pos.x <= this.size) {\n      if (this.vel.x < 0) this.vel.x = -this.vel.x;\n      this.pos.x = this.size;\n    }\n\n    if (this.pos.y >= this.height - this.size) {\n      if (this.vel.y > 0) this.vel.y = -this.vel.y;\n      this.pos.y = this.height - this.size;\n    } else if (this.pos.y <= this.size) {\n      if (this.vel.y < 0) this.vel.y = -this.vel.y;\n      this.pos.y = this.size;\n    }\n\n    // velocity\n    this.pos = this.pos.add(this.vel);\n\n  };\n\n  // lavalamp constructor\n  var LavaLamp = function(width, height, numBalls, c0, c1) {\n    this.step = 5;\n    this.width = width;\n    this.height = height;\n    this.wh = Math.min(width, height);\n    this.sx = Math.floor(this.width / this.step);\n    this.sy = Math.floor(this.height / this.step);\n    this.paint = false;\n    this.metaFill = createRadialGradient(width, height, width, c0, c1);\n    this.plx = [0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0];\n    this.ply = [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1];\n    this.mscases = [0, 3, 0, 3, 1, 3, 0, 3, 2, 2, 0, 2, 1, 1, 0];\n    this.ix = [1, 0, -1, 0, 0, 1, 0, -1, -1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1];\n    this.grid = [];\n    this.balls = [];\n    this.iter = 0;\n    this.sign = 1;\n\n    // init grid\n    for (var i = 0; i < (this.sx + 2) * (this.sy + 2); i++) {\n      this.grid[i] = new Point(\n        (i % (this.sx + 2)) * this.step, (Math.floor(i / (this.sx + 2))) * this.step\n      )\n    }\n\n    // create metaballs\n    for (var k = 0; k < numBalls; k++) {\n      this.balls[k] = new Ball(this);\n    }\n    console.log(this.wh, this.sx, this.sy, this.grid, this.balls)\n  };\n  // compute cell force\n  LavaLamp.prototype.computeForce = function(x, y, idx) {\n\n    var force;\n    var id = idx || x + y * (this.sx + 2);\n\n    if (x === 0 || y === 0 || x === this.sx || y === this.sy) {\n      force = 0.6 * this.sign;\n    } else {\n      force = 0;\n      var cell = this.grid[id];\n      var i = 0;\n      var ball;\n      while (ball = this.balls[i++]) {\n        force += ball.size * ball.size / (-2 * cell.x * ball.pos.x - 2 * cell.y * ball.pos.y + ball.pos.magnitude + cell.magnitude);\n      }\n      force *= this.sign\n    }\n    this.grid[id].force = force;\n    return force;\n  };\n  // compute cell\n  LavaLamp.prototype.marchingSquares = function(next) {\n    var x = next[0];\n    var y = next[1];\n    var pdir = next[2];\n    var id = x + y * (this.sx + 2);\n    if (this.grid[id].computed === this.iter) {\n      return false;\n    }\n    var dir, mscase = 0;\n\n    // neighbors force\n    for (var i = 0; i < 4; i++) {\n      var idn = (x + this.ix[i + 12]) + (y + this.ix[i + 16]) * (this.sx + 2);\n      var force = this.grid[idn].force;\n      if ((force > 0 && this.sign < 0) || (force < 0 && this.sign > 0) || !force) {\n        // compute force if not in buffer\n        force = this.computeForce(\n          x + this.ix[i + 12],\n          y + this.ix[i + 16],\n          idn\n        );\n      }\n      if (Math.abs(force) > 1) mscase += Math.pow(2, i);\n    }\n    if (mscase === 15) {\n      // inside\n      return [x, y - 1, false];\n    } else {\n      // ambiguous cases\n      if (mscase === 5) dir = (pdir === 2) ? 3 : 1;\n      else if (mscase === 10) dir = (pdir === 3) ? 0 : 2;\n      else {\n        // lookup\n        dir = this.mscases[mscase];\n        this.grid[id].computed = this.iter;\n      }\n      // draw line\n      var ix = this.step / (\n          Math.abs(Math.abs(this.grid[(x + this.plx[4 * dir + 2]) + (y + this.ply[4 * dir + 2]) * (this.sx + 2)].force) - 1) /\n          Math.abs(Math.abs(this.grid[(x + this.plx[4 * dir + 3]) + (y + this.ply[4 * dir + 3]) * (this.sx + 2)].force) - 1) + 1\n        );\n      ctx.lineTo(\n        this.grid[(x + this.plx[4 * dir]) + (y + this.ply[4 * dir]) * (this.sx + 2)].x + this.ix[dir] * ix,\n        this.grid[(x + this.plx[4 * dir + 1]) + (y + this.ply[4 * dir + 1]) * (this.sx + 2)].y + this.ix[dir + 4] * ix\n      );\n      this.paint = true;\n      // next\n      return [\n        x + this.ix[dir + 4],\n        y + this.ix[dir + 8],\n        dir\n      ];\n    }\n  };\n\n  LavaLamp.prototype.renderMetaballs = function() {\n    var i = 0, ball;\n    while (ball = this.balls[i++]) ball.move();\n    // reset grid\n    this.iter++;\n    this.sign = -this.sign;\n    this.paint = false;\n    ctx.fillStyle = this.metaFill;\n    ctx.beginPath();\n    // compute metaballs\n    i = 0;\n    //ctx.shadowBlur = 50;\n    //ctx.shadowColor = \"green\";\n    while (ball = this.balls[i++]) {\n      // first cell\n      var next = [\n        Math.round(ball.pos.x / this.step),\n        Math.round(ball.pos.y / this.step), false\n      ];\n      // marching squares\n      do {\n        next = this.marchingSquares(next);\n      } while (next);\n      // fill and close path\n      if (this.paint) {\n        ctx.fill();\n        ctx.closePath();\n        ctx.beginPath();\n        this.paint = false;\n      }\n    }\n  };\n\n  // gradients\n  var createRadialGradient = function(w, h, r, c0, c1) {\n    var gradient = ctx.createRadialGradient(\n      w / 1, h / 1, 0,\n      w / 1, h / 1, r\n    );\n    gradient.addColorStop(0, c0);\n    gradient.addColorStop(1, c1);\n    return gradient;\n  };\n\n  // main loop\n  var run = function() {\n    requestAnimationFrame(run);\n    ctx.clearRect(0, 0, screen.width, screen.height);\n    lava0.renderMetaballs();\n  };\n  // canvas\n  var screen = ge1doot.screen.init(\"bubble\", null, true),\n      ctx = screen.ctx;\n  screen.resize();\n  // create LavaLamps\n  lava0 = new LavaLamp(screen.width, screen.height, 6, \"#FF9298\", \"#E4008E\");\n\n  run();\n\n})();"],"file":"bubble.js"}